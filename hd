import cv2
import os
import numpy as np
 
def crop_around_poles(image_path, pole_locations, crop_size=256, output_dir="cropped_images"):
     
   # --- 1. Load the image ---
   img = cv2.imread(image_path)
   if img is None:
       print(f"Error: Could not load image at {image_path}")
       return
 
   # Create the output directory if it doesn't exist
   os.makedirs(output_dir, exist_ok=True)
   
   # Get the base filename (without extension) for saving
   base_name = os.path.splitext(os.path.basename(image_path))[0]
   
   half_crop = crop_size // 2
 
   # --- 2. Iterate and Crop ---
   for i, (center_x, center_y) in enumerate(pole_locations):
       
       # Determine the bounding box coordinates for the crop
       # We ensure the coordinates stay within the image boundaries (0 to width/height)
       
       # Calculate the raw top-left and bottom-right corners
       x_min_raw = center_x - half_crop
       y_min_raw = center_y - half_crop
       x_max_raw = center_x + half_crop
       y_max_raw = center_y + half_crop
 
       # Determine the padding needed if the crop goes outside the image
       # This is useful if you want to zero-pad the edges instead of just cutting them off
       pad_left = abs(min(0, x_min_raw))
       pad_top = abs(min(0, y_min_raw))
       pad_right = abs(min(0, img.shape[1] - x_max_raw))
       pad_bottom = abs(min(0, img.shape[0] - y_max_raw))
       
       # Clamp coordinates to the image boundaries
       x_min = max(0, x_min_raw)
       y_min = max(0, y_min_raw)
       x_max = min(img.shape[1], x_max_raw) # img.shape[1] is the width
       y_max = min(img.shape[0], y_max_raw) # img.shape[0] is the height
 
       # --- 3. Perform the basic crop ---
       cropped_img = img[y_min:y_max, x_min:x_max]
 
       # --- 4. Padding (if necessary) to enforce exact crop_size ---
       # This step is crucial if the pole is near the edge and the transformer
       # model requires an exact size (e.g., 256x256).
       if cropped_img.shape[0] != crop_size or cropped_img.shape[1] != crop_size:
           
           # Use OpenCV's copyMakeBorder to add padding (e.g., black border)
           # cv2.BORDER_CONSTANT fills with a constant color (default 0=black)
           padded_crop = cv2.copyMakeBorder(
               cropped_img,
               top=pad_top,
               bottom=pad_bottom,
               left=pad_left,
               right=pad_right,
               borderType=cv2.BORDER_CONSTANT,
               value=(0, 0, 0) # Black color for RGB/BGR image
           )
           final_crop = padded_crop
       else:
           final_crop = cropped_img
 
 
       # --- 5. Save the cropped image ---
       output_filename = os.path.join(output_dir, f"{base_name}_pole_{i+1}_{crop_size}x{crop_size}.png")
       cv2.imwrite(output_filename, final_crop)
       print(f"Saved crop for pole {i+1} to {output_filename}")
 
 
# --- Example Usage ---
 
# 1. Define the path to your image
IMAGE_PATH = "path/to/your/image.jpg" # <-- **CHANGE THIS**
 
# 2. Define the detected pole locations (Center X, Center Y).
#    In a real scenario, this data would come from your 'pole model' output.
#    (Using example values here)
POLE_LOCATIONS = [
   (100, 500),   # Pole 1 near the left edge
   (800, 300),   # Pole 2 in the middle
   (1900, 900)   # Pole 3 near the right edge (if image is 2000 wide)
]
 
# 3. Define the required crop size for your transformer model
CROP_SIZE_PIXELS = 256
 
# 4. Run the script
# crop_around_poles(IMAGE_PATH, POLE_LOCATIONS, CROP_SIZE_PIXELS)
 
 
