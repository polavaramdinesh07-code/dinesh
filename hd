# Use the df you already built/flattened above

# 1) Normalize columns -> ensure width/height exist
df = sanitize_columns(df)           # uses your helper you defined
df = add_derivatives(df)            # adds area, aspect, coco buckets, valid_dims, etc.

# 2) Keep valid boxes only for size stats
dfv = df[df["valid_dims"]].copy()

# 3) Stats by class
by_class = (
    dfv.groupby("class_name")
       .agg(
           boxes=("image","size"),
           w_min=("width","min"),  w_med=("width","median"),  w_mean=("width","mean"),
           h_min=("height","min"), h_med=("height","median"), h_mean=("height","mean"),
           area_mean=("area","mean"), ar_mean=("aspect","mean")
       )
       .reset_index()
)

# 4) COCO size mix (small/medium/large) per class
size_mix = (
    dfv.groupby(["class_name","coco_size"])
       .size().unstack(fill_value=0).reset_index()
)

# 5) Counts per image
per_image = (
    dfv.groupby("image").agg(total_boxes=("class_name","size")).reset_index()
    .sort_values("total_boxes", ascending=False)
)

# 6) Invalid summary (non-positive dims + any out-of-bounds you flagged earlier)
invalid = df[~df["valid_dims"]]
invalid_summary = invalid.assign(reason="non_positive_width_or_height") \
                         .groupby("reason").size().reset_index(name="count")

# 7) Write outputs (local or S3, per your OUTDIR)
write_outputs(by_class, size_mix, per_image, invalid_summary, OUTDIR)
print("Wrote:", ["bbox_stats_by_class.csv",
                 "bbox_coco_buckets_by_class.csv",
                 "bbox_counts_per_image.csv",
                 "bbox_invalid_summary.csv"])
