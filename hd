# If needed (first run)
!pip install -q pandas numpy s3fs boto3




import os, json
import numpy as np
import pandas as pd




# <<< EDIT THIS >>>
# Example: s3 CSV or JSON with columns like:
# image, class_name (or label), xmin, ymin, xmax,ymax or width,height, (optional) img_width,img_height
INPUT_URI = "s3://YOUR-BUCKET/YOUR-FOLDER/your_boxes.csv"   # or .../your_boxes.json

# Optional: where to write outputs (local or back to S3)
OUTDIR = "bbox_stats_out"  # local folder
# If you prefer to write to S3 instead, set: OUTDIR = "s3://YOUR-BUCKET/some/folder/bbox_stats_out"




def load_table(uri: str) -> pd.DataFrame:
    """Load CSV or JSON (list of dicts) from local path or S3 (needs s3fs)."""
    if uri.lower().endswith(".csv"):
        return pd.read_csv(uri)
    elif uri.lower().endswith(".json"):
        with open(uri, "r") if uri.startswith(("file://","/")) else \
             pd.io.common.get_handle(uri, 'r').handle as f:
            data = json.load(f)
        if isinstance(data, list):
            return pd.DataFrame(data)
        elif isinstance(data, dict) and "data" in data and isinstance(data["data"], list):
            return pd.DataFrame(data["data"])
        else:
            raise ValueError("JSON must be a list of rows or have a top-level 'data' list.")
    else:
        raise ValueError("Only .csv or .json inputs are supported.")

def sanitize_columns(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    # allow `label` instead of `class_name`
    if "class_name" not in df.columns and "label" in df.columns:
        df["class_name"] = df["label"]

    # make width/height if xmax/ymax present
    have_xyxy = {"xmin","ymin","xmax","ymax"}.issubset(df.columns)
    have_xywh = {"xmin","ymin","width","height"}.issubset(df.columns)
    if not (have_xyxy or have_xywh):
        raise ValueError("Need (xmin,ymin,xmax,ymax) OR (xmin,ymin,width,height).")

    if have_xyxy and not have_xywh:
        df["width"]  = df["xmax"] - df["xmin"]
        df["height"] = df["ymax"] - df["ymin"]

    needed = {"image","class_name","xmin","ymin","width","height"}
    missing = [c for c in needed if c not in df.columns]
    if missing:
        raise ValueError(f"Missing required columns: {missing}")

    df["valid_dims"] = (df["width"] > 0) & (df["height"] > 0)

    if {"img_width","img_height"}.issubset(df.columns):
        df["xmax"] = df["xmin"] + df["width"]
        df["ymax"] = df["ymin"] + df["height"]
        df["oob_any"] = (df["xmin"] < 0) | (df["ymin"] < 0) | \
                        (df["xmax"] > df["img_width"]) | (df["ymax"] > df["img_height"])
        df["w_norm"] = df["width"]  / df["img_width"].replace(0,np.nan)
        df["h_norm"] = df["height"] / df["img_height"].replace(0,np.nan)
    else:
        df["oob_any"] = False

    return df

def add_derivatives(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    df["area"]   = df["width"] * df["height"]
    df["aspect"] = df["width"] / df["height"].replace(0,np.nan)

    def coco_bucket(a):
        if a < 32*32:   return "small"
        elif a <= 96*96:return "medium"
        else:           return "large"
    df["coco_size"] = df["area"].apply(coco_bucket)
    return df

def write_outputs(by_class, size_mix, per_image, invalid_summary, outdir):
    os.makedirs(outdir, exist_ok=True) if not outdir.startswith("s3://") else None

    by_class.to_csv(f"{outdir.rstrip('/')}/bbox_stats_by_class.csv", index=False)
    size_mix.to_csv(f"{outdir.rstrip('/')}/bbox_coco_buckets_by_class.csv", index=False)
    per_image.to_csv(f"{outdir.rstrip('/')}/bbox_counts_per_image.csv", index=False)
    invalid_summary.to_csv(f"{outdir.rstrip('/')}/bbox_invalid_summary.csv", index=False)

    print("Wrote:")
    for f in ["bbox_stats_by_class.csv",
              "bbox_coco_buckets_by_class.csv",
              "bbox_counts_per_image.csv",
              "bbox_invalid_summary.csv"]:
        print("  -", f"{outdir.rstrip('/')}/{f}")




df = load_table(INPUT_URI)
# Allow `label` alias here too
if "class_name" not in df.columns and "label" in df.columns:
    df["class_name"] = df["label"]

# Minimal identity check
for c in ["image","class_name","xmin","ymin"]:
    if c not in df.columns:
        raise ValueError(f"Input must include column: {c}")

df = sanitize_columns(df)
df = add_derivatives(df)

# Keep only valid for size summaries
dfv = df[df["valid_dims"]].copy()

by_class = (dfv.groupby("class_name")
    .agg(
        boxes=("image","size"),
        w_min=("width","min"),   w_med=("width","median"),   w_mean=("width","mean"),   w_max=("width","max"),
        h_min=("height","min"),  h_med=("height","median"),  h_mean=("height","mean"),  h_max=("height","max"),
        a_min=("area","min"),    a_med=("area","median"),    a_mean=("area","mean"),    a_max=("area","max"),
        ar_med=("aspect","median"), ar_mean=("aspect","mean")
    ).reset_index()
)

if {"w_norm","h_norm"}.issubset(dfv.columns):
    extra = (dfv.groupby("class_name")
             .agg(w_norm_med=("w_norm","median"), h_norm_med=("h_norm","median"),
                  w_norm_mean=("w_norm","mean"),  h_norm_mean=("h_norm","mean"))
             .reset_index())
    by_class = by_class.merge(extra, on="class_name", how="left")

size_mix = (dfv.groupby(["class_name","coco_size"])
            .size().reset_index(name="count")
            .pivot(index="class_name", columns="coco_size", values="count")
            .fillna(0).astype(int).reset_index())

per_image = (df.groupby("image")
             .agg(total_boxes=("class_name","size"))
             .reset_index()
             .sort_values("total_boxes", ascending=False))

invalid = df[~df["valid_dims"]]
invalid_summary = (invalid.assign(reason=np.where(~invalid["valid_dims"], "non_positive_width_or_height", "other"))
                   .groupby("reason").size().reset_index(name="count"))
if "oob_any" in df.columns:
    oob = df[df["oob_any"]]
    if not oob.empty:
        oob_summary = oob.assign(reason="out_of_bounds").groupby("reason").size().reset_index(name="count")
        invalid_summary = pd.concat([invalid_summary, oob_summary], ignore_index=True).groupby("reason").sum().reset_index()

write_outputs(by_class, size_mix, per_image, invalid_summary, OUTDIR)
